# План оптимизации производительности Network Bot

В ходе глубокого анализа кодовой базы были выявлены критические проблемы, влияющие на масштабируемость и стоимость эксплуатации (деньги).

## 1. Асинхронность и Параллелизм (Мгновенное ускорение)

### Проблема 1: Последовательные вызовы в Matching
В `MatchService.find_peer_matches` бот ищет совпадения, перебирая кандидатов по очереди.
* **Влияние**: Проверка одного кандидата = 2 сек. 5 кандидатов = 10 сек ожидания.
* **Решение**: Переписать на `asyncio.gather` для одновременной проверки всех кандидатов. Время сократится до ~2-3 сек независимо от количества.

### Проблема 2: Блокировка базы данных (DB Pool Exhaustion)
При выполнении `find_peer_matches` (длится 10-30 сек) бот держит открытой транзакцию/сессию к PostgreSQL.
* **Риск**: Если у вас пул 10 соединений, то **11 пользователей**, нажавших "Найти совпадения", **положат весь бот** (остальные запросы встанут в очередь и отвалятся по таймауту).
* **Решение**: Архитектурно разделить чтение данных и AI-обработку.
    1. Прочитать контакты из БД.
    2. **Закрыть сессию БД** (освободить слот).
    3. Сделать долгие запросы к AI.
    4. Открыть новую сессию для сохранения результата (если нужно).

### Проблема 3: Лишние соединения (overhead)
В `OSINTService` создается новая сессия `aiohttp` на каждый микро-запрос.
* **Решение**: Использовать одну сессию на весь цикл обогащения.

## 2. База данных и Поиск (Масштабируемость)

### Проблема 4: Медленный поиск (`ilike`)
Поиск `Contact.name.ilike('%query%')` делает полный перебор таблицы (Seq Scan).
* **Решение**: Включить `pg_trgm` и GIN индексы.

### Проблема 5: "Тяжелые" запросы (Select *)
При выводе списков (меню) загружаются поля `raw_transcript` и `osint_data`.
* **Влияние**: Если транскрипция встречи большая (50Кб), то список из 10 контактов тянет 0.5Мб данных из БД, хотя нужны только имена.
* **Решение**: Использовать `.options(load_only(Contact.id, Contact.name, ...))` в методах `get_all_contacts` и `get_recent_contacts`.

## 3. Экономия денег и Лимиты (Caching & Tokens)

### Проблема 6: Отсутствие кэширования матчей
Если пользователь дважды нажмет "Найти совпадения", бот дважды заплатит за токены Gemini.
* **Решение**: Создать таблицу `matches` и сохранять результаты на 24-48 часов.

### Проблема 7: Семантический поиск "в лоб"
Загрузка всех контактов в промпт для поиска — это дорого (токены) и не масштабируется (>50 контактов не влезут).
* **Решение**: Внедрить векторный поиск (`pgvector`) + Embeddings.

## План работ

### Этап 1: Code Optimization (Срочно)
1. [x] **FIX**: `MatchService`: внедрить `asyncio.gather` (параллелизм).
2. [x] **FIX**: `MatchService`: "Отвязать" AI запросы от БД сессии (detach objects), чтобы не блокировать пул соединений.
3. [x] **FIX**: `ContactService`: Добавить `load_only` для списочных методов.

### Этап 2: DB Tuning
1. [x] **MIGRATE**: Добавить индексы `pg_trgm`.

### Этап 3: Cache & Features
1. [x] **FEATURE**: Таблица кэша для матчей.
